import type { paths, components } from "./sep25_2024.d.ts"; // auto-generated by openapi-typescript
import createClient from "openapi-fetch";
import type {LSPConfig, LspLogger} from "../lsp/config.js";

export type { paths, components};

/** aka 'Function' name */
type EndpointName = string;

type Client = ReturnType<typeof createClient<paths>>;

type ExtendedPOST<T extends Client['POST']> = (endpointName: string, ...args: Parameters<T>) => ReturnType<T>;

export class APIClient {
  #client: Client; 
  #currentEndpoints: Set<EndpointName>;
  #logger: LspLogger;

  static make(config: LSPConfig) {
    const client = new APIClient(config);
    client.updateEndpointInfo();
    return client;
  }

  private constructor(
    config: LSPConfig
  ) {
    this.#client = createClient<paths>({
      baseUrl: config.getDecisionServiceUrl()
    });

    this.#currentEndpoints = new Set();
    this.#logger = config.getLogger();
  }

  updateWithProgram: ExtendedPOST<Client['POST']> = async (endpointName, path, ...init) => {
    if (!this.#currentEndpoints.has(endpointName)) {
      const { data, error } = await this.#client.POST(path, ...init);
      if (data) {
        this.#currentEndpoints.add(endpointName);
        this.#logger.info("Successfully updated decision service program: ", data);
      } else if (error) {
        this.#logger.error("ERROR", error);
      }
    }
  }

  async getCurrentEndpoints() {
    const { data, error } = await this.#client.GET("/functions", {});
    if (data) {
      return data;
    } else {
      return error;
    }
  }
  
  async updateEndpointInfo() {
    const { data, error } = await this.#client.GET("/functions", {});
    if (data) {
      const endpoints: EndpointName[] = data.map(fn => fn.function?.name)
                                            .filter((n): n is string => n !== undefined);
      this.#currentEndpoints = new Set(endpoints);
    } else {
      console.error(error);
    }
  }

  PUT: Client["PUT"] = (path, ...init) => {
    return this.#client.PUT(path, ...init);
  }

  DELETE: Client["DELETE"] = (path, ...init) => {
    return this.#client.DELETE(path, ...init);
  }

}

