/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/functions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Shortened descriptions of all available functions and their parameters */
        get: operations["getAllFunctions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/functions/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a detailed description of the function and its parameters */
        get: operations["getFunction"];
        /** Update a function resource */
        put: operations["updateFunction"];
        /** Add a function resource that can be evaluated. */
        post: operations["createFunction"];
        /** Delete the function */
        delete: operations["deleteFunction"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/functions/{name}/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run a function using a batch of arguments
         * @description Evaluate a function with a batch of arguments, conforming to Oracle Intelligent Advisor Batch API
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BatchRequest"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json;charset=utf-8": components["schemas"]["BatchResponse"];
                    };
                };
                /** @description Invalid `body` */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description `name` not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/functions/{name}/evaluation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Evaluate a function with arguments */
        post: operations["evalFunction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Batch Request */
        BatchRequest: {
            cases?: ({
                /**
                 * @default 0
                 * @example 0
                 */
                "@id": number;
            } & {
                [key: string]: unknown;
            })[];
            outcomes?: (string | ({
                "@id"?: string;
            } & {
                [key: string]: unknown;
            }))[];
        };
        /** Batch Response */
        BatchResponse: {
            cases?: ({
                /**
                 * @default 0
                 * @example 0
                 */
                "@id": number;
            } & {
                [key: string]: unknown;
            })[];
            summary?: {
                /**
                 * @default 0
                 * @example 0
                 */
                casesIgnored: number;
                /**
                 * @default 0
                 * @example 0
                 */
                casesProcessed: number;
                /**
                 * @default 0
                 * @example 0
                 */
                casesRead: number;
                /** Format: double */
                processorCasesPerSec?: number;
                /** Format: double */
                processorDurationSec?: number;
                /** Format: double */
                processorQueuedSec?: number;
            };
        };
        /**
         * Evaluation Backends
         * @description Backend for evaluation of a function. Backends can greatly affect the explanation quality. Additionally, backends may or may not support parts of natural4.
         * @default simala
         * @example simala
         * @enum {string}
         */
        EvalBackend: "simala" | "gml";
        EvaluatorError: {
            contents: string;
            /** @enum {string} */
            tag: "InterpreterError";
        } | {
            contents: components["schemas"]["ParameterMismatch"];
            /** @enum {string} */
            tag: "RequiredParameterMissing";
        } | {
            contents: string[];
            /** @enum {string} */
            tag: "UnknownArguments";
        } | {
            /** @enum {string} */
            tag: "CannotHandleUnknownVars";
        };
        FnArguments: {
            fnArguments: {
                [key: string]: components["schemas"]["Literal"];
            };
            fnEvalBackend?: components["schemas"]["EvalBackend"];
        };
        /** Function */
        Function: {
            function?: {
                description?: string;
                name?: string;
                parameters?: {
                    properties?: components["schemas"]["FunctionParameters"];
                    type?: string;
                };
                supportedBackends?: components["schemas"]["EvalBackend"][];
            };
            type?: string;
        };
        /**
         * Parameter
         * @example {
         *       "alias": "w",
         *       "description": "Can a person walk?",
         *       "enum": [
         *         "true",
         *         "false",
         *         "uncertain"
         *       ],
         *       "type": "string"
         *     }
         */
        FunctionParameter: {
            alias?: string;
            description?: string;
            enum?: string[];
            type: string;
        };
        FunctionParameters: {
            [key: string]: components["schemas"]["FunctionParameter"];
        };
        /** Implementation */
        Implementation: {
            declaration?: components["schemas"]["Function"];
            implementation?: [
                components["schemas"]["EvalBackend"],
                string
            ][];
        };
        /**
         * Argument
         * @description A Function argument which can be either 'true' or 'false', or a floating point number. Additionally accepts 'yes' and 'no' as synonyms for 'true' and 'false' respectively.
         * @example true
         */
        Literal: string;
        ParameterMismatch: {
            actualParameters: number;
            expectedParameters: number;
        };
        ReasonNode: {
            reasoningNodeExampleCode: string[];
            reasoningNodeExplanation: string[];
        };
        Reasoning: {
            getReasoning: components["schemas"]["ReasoningTree"];
        };
        ReasoningTree: {
            treeChildren: components["schemas"]["ReasoningTree"][];
            treeNode: components["schemas"]["ReasonNode"];
        };
        ResponseWithReason: {
            responseReasoning: components["schemas"]["Reasoning"];
            responseValue: [
                string,
                components["schemas"]["Literal"]
            ][];
        };
        SimpleResponse: {
            contents: components["schemas"]["ResponseWithReason"];
            /** @enum {string} */
            tag: "SimpleResponse";
        } | {
            contents: components["schemas"]["EvaluatorError"];
            /** @enum {string} */
            tag: "SimpleError";
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getAllFunctions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Function"][];
                };
            };
        };
    };
    getFunction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Function"];
                };
            };
            /** @description `name` not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateFunction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json;charset=utf-8": components["schemas"]["Implementation"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": unknown[];
                };
            };
            /** @description Invalid `body` */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `name` not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createFunction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json;charset=utf-8": components["schemas"]["Implementation"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": unknown[];
                };
            };
            /** @description Invalid `body` */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `name` not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteFunction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": unknown[];
                };
            };
            /** @description `name` not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    evalFunction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json;charset=utf-8": components["schemas"]["FnArguments"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["SimpleResponse"];
                };
            };
            /** @description Invalid `body` */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `name` not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
